from abc import ABC
from enum import Enum, auto
from typing import List, Tuple, final

class NumExpr(ABC):
    def __ge__(self, other) -> NumExpr: ...
    def __gt__(self, other) -> NumExpr: ...
    def __le__(self, other) -> NumExpr: ...
    def __lt__(self, other) -> NumExpr: ...
    def __mul__(self, other) -> NumExpr: ...
    def __eq__(self, other) -> NumExpr: ...  # type: ignore[override]
    def __ne__(self, other) -> NumExpr: ...  # type: ignore[override]
    def __neg__(self) -> NumExpr: ...
    def __add__(self, other) -> NumExpr: ...
    def __radd__(self, other) -> NumExpr: ...
    def __rmul__(self, other) -> NumExpr: ...
    def __sub__(self, other) -> NumExpr: ...
    def __rsub__(self, other) -> NumExpr: ...
    def __truediv__(self, other) -> NumExpr: ...
    def __rtruediv__(self, other) -> NumExpr: ...
    def __abs__(self) -> NumExpr: ...

@final
class ConstInt(NumExpr):
    def __init__(self, value: int): ...

@final
class ConstUInt(NumExpr):
    def __init__(self, value: int): ...

@final
class ConstFloat(NumExpr):
    def __init__(self, value: float): ...

@final
class VarInt(NumExpr):
    def __init__(self, name: str): ...

@final
class VarUInt(NumExpr):
    def __init__(self, name: str): ...

@final
class VarFloat(NumExpr):
    def __init__(self, name: str): ...

@final
class Negate(NumExpr):
    def __init__(self, arg: NumExpr): ...

@final
class Add(NumExpr):
    def __init__(self, args: List[NumExpr]): ...

@final
class Mul(NumExpr):
    def __init__(self, args: List[NumExpr]): ...

@final
class Div(NumExpr):
    def __init__(self, dividend: NumExpr, divisor: NumExpr): ...

@final
class Abs(NumExpr):
    def __init__(self, arg: NumExpr): ...

class BoolExpr(ABC):
    def __and__(self, other) -> BoolExpr: ...
    def __invert__(self) -> BoolExpr: ...
    def __or__(self, other) -> BoolExpr: ...
    def __rand__(self, other) -> BoolExpr: ...
    def __ror__(self, other) -> BoolExpr: ...

@final
class ConstBool(BoolExpr):
    def __init__(self, value: bool): ...

@final
class VarBool(BoolExpr):
    def __init__(self, name: str): ...

@final
class Cmp(BoolExpr):
    @staticmethod
    def equal(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...
    @staticmethod
    def greater_than(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...
    @staticmethod
    def greater_than_eq(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...
    @staticmethod
    def less_than(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...
    @staticmethod
    def less_than_eq(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...
    @staticmethod
    def not_equal(lhs: NumExpr, rhs: NumExpr) -> Cmp: ...

@final
class Not(BoolExpr):
    def __init__(self, arg: BoolExpr): ...

@final
class And(BoolExpr):
    def __init__(self, args: List[BoolExpr]): ...

@final
class Or(BoolExpr):
    def __init__(self, args: List[BoolExpr]): ...

@final
class Next(BoolExpr):
    def __init__(self, arg: BoolExpr): ...

@final
class Always(BoolExpr):
    def __init__(self, arg: BoolExpr): ...

@final
class Eventually(BoolExpr):
    def __init__(self, arg: BoolExpr): ...

@final
class Until(BoolExpr):
    def __init__(self, lhs: BoolExpr, rhs: BoolExpr): ...

@final
class DType(Enum):
    Bool = auto()
    Int = auto()
    UnsignedInt = auto()
    Float = auto()

class Signal(ABC): ...

@final
class BoolSignal(Signal):
    def __init__(self): ...
    @staticmethod
    def constant(value: bool) -> BoolSignal: ...
    @staticmethod
    def from_samples(samples: List[Tuple[float, bool]]) -> BoolSignal: ...
    def push(self, time, value): ...

@final
class IntSignal(Signal):
    def __init__(self): ...
    @staticmethod
    def constant(value: int) -> IntSignal: ...
    @staticmethod
    def from_samples(samples: List[Tuple[float, int]]) -> IntSignal: ...
    def push(self, time, value): ...

@final
class UnsignedIntSignal(Signal):
    def __init__(self): ...
    @staticmethod
    def constant(value: int) -> UnsignedIntSignal: ...
    @staticmethod
    def from_samples(samples: List[Tuple[float, int]]) -> UnsignedIntSignal: ...
    def push(self, time, value): ...

@final
class FloatSignal(Signal):
    def __init__(self): ...
    @staticmethod
    def constant(value: float) -> UnsignedIntSignal: ...
    @staticmethod
    def from_samples(samples: List[Tuple[float, float]]) -> FloatSignal: ...
    def push(self, time, value): ...

@final
class Trace: ...

def eval_bool_semantics(expr: BoolExpr, trace: Trace) -> BoolSignal: ...
def eval_robust_semantics(expr: BoolExpr, trace: Trace) -> BoolSignal: ...
