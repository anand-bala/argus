#![warn(missing_docs)]
#![doc = include_str!("../../README.md")]

extern crate self as argus;

mod core;
pub mod parser;
mod semantics;

use std::time::Duration;

use thiserror::Error;

pub use crate::core::signals::{AnySignal, Signal};
pub use crate::core::{expr, signals};
pub use crate::parser::parse_str;
pub use crate::semantics::{BooleanSemantics, QuantitativeSemantics, Trace};

#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub(crate) enum Type {
    #[default]
    Unknown,
    Bool,
    UInt,
    Int,
    Float,
}

impl Type {
    /// Get the lowest common supertype for the given types to a common
    fn get_common_cast(self, other: Self) -> Self {
        use Type::*;
        match (self, other) {
            (Unknown, other) | (other, Unknown) => other,
            (Bool, ty) | (ty, Bool) => ty,
            (UInt, Int) => Float,
            (UInt, Float) => Float,
            (Int, UInt) => Float,
            (Int, Float) => Float,
            (Float, UInt) => Float,
            (Float, Int) => Float,
            (lhs, rhs) => {
                assert_eq!(lhs, rhs);
                rhs
            }
        }
    }
}

/// Errors generated by all Argus components.
#[derive(Error, Debug, PartialEq, Eq)]
pub enum Error {
    /// An identifier has been redeclared in a specification.
    ///
    /// This is called mainly from [`expr::ExprBuilder`].
    #[error("redeclaration of identifier with different type")]
    IdentifierRedeclaration,

    /// An expression is provided with an insufficient number of arguments.
    ///
    /// This is called for N-ary expressions:
    /// [`NumExpr::Add`](crate::expr::NumExpr::Add),
    /// [`NumExpr::Mul`](crate::expr::NumExpr::Mul),
    /// [`BoolExpr::And`](crate::expr::BoolExpr::And), and
    /// [`BoolExpr::Or`](crate::expr::BoolExpr::Or).
    #[error("insufficient number of arguments")]
    IncompleteArgs,

    /// Attempting to `push` a new sample to a non-sampled signal
    /// ([`Signal::Empty`](crate::signals::Signal::Empty) or
    /// [`Signal::Constant`](crate::signals::Signal::Constant)).
    #[error("cannot push value to non-sampled signal")]
    InvalidPushToSignal,

    /// Pushing the new value to the sampled signal makes it not strictly monotonically
    /// increasing.
    #[error(
        "trying to create a signal with non-monotonic time points, signal end time ({end_time:?}) > sample time point \
         ({current_sample:?})"
    )]
    NonMonotonicSignal {
        /// The time that the signal actually ends
        end_time: Duration,
        /// The time point of the new (erroneous) sample.
        current_sample: Duration,
    },

    /// Attempting to perform an invalid operation on a signal
    #[error("invalid operation on signal")]
    InvalidOperation,

    /// Attempting to index a signal not present in a trace.
    #[error("name not in signal trace")]
    SignalNotPresent,

    /// Attempting to perform a signal operation not supported by the type
    #[error("incorrect signal type")]
    InvalidSignalType,

    /// Incorrect cast of signal
    #[error("invalid cast from {from} to {to}")]
    InvalidCast {
        /// Type of the signal being cast from
        from: &'static str,
        /// Type of the signal being cast to
        to: &'static str,
    },

    /// Invalid interval
    #[error("invalid interval: {reason}")]
    InvalidInterval {
        /// Reason for interval being invalid
        reason: &'static str,
    },
}

impl Error {
    /// An [`InvalidCast`](Error::InvalidCast) error from `T` to `U`.
    pub fn invalid_cast<T, U>() -> Self {
        Self::InvalidCast {
            from: std::any::type_name::<T>(),
            to: std::any::type_name::<U>(),
        }
    }
}

/// Alias for [`Error`](enum@Error)
pub type ArgusError = Error;
/// Alias for [`Result<T, ArgusError>`]
pub type ArgusResult<T> = Result<T, Error>;
